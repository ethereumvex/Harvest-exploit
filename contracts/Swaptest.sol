//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.0;

import "hardhat/console.sol";
import "./IUniswapV2Interfaces.sol";
import "./IcurveYSwap.sol";
import "./IHarvestUsdcVault.sol";
import "./IERC20USDT.sol";

contract Swaptest {

  // CONTRACTS
  // Uniswap ETH/USDC LP (UNI-V2)
  IUniswapV2Pair usdcPair = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);
  // Uniswap ETH/USDT LP (UNI-V2)
  IUniswapV2Pair usdtPair = IUniswapV2Pair(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);

  // ERC20s
  // 6 decimals on usdc
  IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
  // WETH
  IWETH weth = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
  // 6 decimals on usdt
  IERC20USDT usdt = IERC20USDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);

  uint wethBorrow = 400*10**18;

  // I was having issues building the exploit and wanted to parse out some of the actions
  // and test them on their own. Here is the double flash swap where we use some of the 
  // eth from the ethers provider to cover the interest and pay back the loans.
  // What has to happen:
  // 1. Make the required approvals.
  // 2. Convert 800 of our ETH to WETH (800 = arbitrary).
  // 3. Call the first swap which leads back into uniswapV2Call
  // 4. Call the second swap which leads back into uniswapV2Call
  // 5. Pay back the second swap
  // 6. Pay back the first swap

  constructor() {
    // #1, going to do our approves here:
    usdc.approve(address(usdcPair), uint(-1));
    usdt.approve(address(usdtPair), uint(-1));

  }

  function run() public {  
    // #2 Convert 800 of our ETH to WETH
    weth.deposit{value: 800*10**18}();
    console.log("WETH held: ", weth.balanceOf(address(this)) / 10**18);

    // #3, Call the first swap which leads back into uniswapV2Call
    console.log("Borrow from USDC");
    usdcPair.swap(0, wethBorrow, address(this), "0x");
    console.log("Done");
    console.log("WETH held: ", weth.balanceOf(address(this)) / 10**18);
}

  function uniswapV2Call(address,uint,uint,bytes calldata) external {
    console.log(".");
    uint wethToReturn = (wethBorrow * 1 * 100301) / 100000;
    console.log("WETH held: ", weth.balanceOf(address(this)) / 10**18);

    // This is the first entry, so borrow from the next pool and enter again:
    if(msg.sender == address(usdcPair)) {
      console.log("First entry to UNiV2 Call");
      console.log("Borrow from USDT");
      // #4, Call the second swap which leads back into uniswapV2Call
      // from here Uniswap re-enters this contract on line #74
      usdtPair.swap(wethBorrow, 0, address(this), "0x"); // GOTO line #74
      // #6, Back from the second swap, pay back the first swap
      weth.transfer(address(usdcPair), wethToReturn);

    } 
    // in here is where the exploit would happen
    if(msg.sender == address(usdtPair)) {
      console.log("Second entry to UNiV2 Call");
      console.log("WETH after second borrow: ", weth.balanceOf(address(this)) / 10**18);
      // #5, Pay back the second swap
      weth.transfer(address(usdtPair), wethToReturn);

    } 

  }
  // Fallback must be payable
  fallback() external payable {}
  receive() external payable {}         
}
